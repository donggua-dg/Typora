# 内存模型

![image-20220306200937999](E:\Typora\笔记\JVM.assets\image-20220306200937999.png)



## 线程共享部分

- **堆**：保存实例对象和数组

  - 分为年轻代、老年代两个区域，年轻代还被进一步划分为 Eden 区、From Survivor 0、To Survivor 1 区。

  ![image-20220306194056744](E:\Typora\笔记\JVM.assets\image-20220306194056744.png)

  - 当有对象需要分配时，一个对象永远优先被分配在年轻代的 Eden 区，等到 Eden 区域内存不够时，Java 虚拟机会启动垃圾回收。此时 Eden 区中没有被引用的对象的内存就会被回收，而一些存活时间较长的对象则会进入到老年代。在 JVM 中有一个名为 -XX:MaxTenuringThreshold 的参数专门用来设置晋升到老年代所需要经历的 GC 次数，即在年轻代的对象经过了指定次数的 GC 后，将在下次 GC 时进入老年代。

- **方法区**：存储 Java 类字节码数据的一块区域，它存储了每一个类的结构信息，例如运行时常量池、字段和方法数据、构造方法等。



## 线程私有部分

**程序计数器**：保存线程当前正在执行的方法。

**虚拟机栈**：用来存储栈帧，即存储局部变量与一些过程结果的地方。

**本地方法栈**：使用其他语言（例如 C 语言）来执行java代码时使用。



# 内存溢出和内存泄漏

- 内存溢出：申请的内存空间,超出设置的最大堆内存空间（OutOfMemoryError异常）
  - 原因：创建的对象过多或数组容量过大
- 内存泄漏：其实包含内存溢出,堆内存空间被无用对象占用没有及时释放，导致占用内存，最终导致内存泄露。



# 栈溢出

- 线程请求的栈深度大于虚拟机允许的最大深度 StackOverflowError
- 虚拟机在扩展栈深度时，无法申请到足够的内存空间 OutOfMemoryError



# 直接内存（堆外内容）

- 除了堆可以存对象数据以外，也可以申请堆外内存（直接内存），这部分内存不受jvm管控
- 需要自行申请和释放（本质就是jvm通过c/c++调佣malloc函数申请的内存）
- 最大容量受本机最大内存限制，超出还是会抛出OutOfMemoryError异常



# 类加载过程

JVM 虚拟机执行 class 字节码的过程可以分为七个阶段：**加载、验证、准备、解析、初始化、使用、卸载。**

- **加载**
  - 将字节码转化为二进制字节流加载到内存中
  - 接着为这个类在 JVM 的方法区创建一个对应的 Class 对象，这个 Class 对象就是这个类各种数据的访问入口。

- **验证**
  - 当代码数据被加载到内存中后，虚拟机就会代码数据进行校验，判断这份代码是否符合JVM规范，只有符合 JVM 字节码规范的文件才能被 JVM 正确执行。
  - 两个类型：
    - **JVM规范校验**
    - **代码逻辑校验**

- **准备**
  - 校验完成后，JVM 会开始为类的静态变量以及被final修饰的变量分配内存并初始化
    - 这里的初始化指的是为变量赋予 Java 语言中该数据类型的零值，而不是用户代码里初始化的值。
  - 「类成员变量」的内存分配需要等到初始化阶段才开始。

- **解析**
  - JVM 针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类引用进行解析。这个阶段的主要任务是将其在常量池中的符号引用替换成直接其在内存中的直接引用。
- **初始化**
  - JVM 会根据语句执行顺序对类对象进行初始化，一般来说当 JVM 遇到下面 5 种情况的时候会触发初始化：
    - 遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。
    - 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
    - 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
    - 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。
    - 当使用 JDK1.7 动态语言支持时，如果一个 java.lang.invoke.MethodHandle实例最后的解析结果 REF_getstatic,REF_putstatic,REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。

- **使用**
  - 当 JVM 完成初始化阶段之后，JVM 便开始从入口方法开始执行用户的程序代码
- **卸载**
  - 当用户程序代码执行完毕后，JVM 便开始销毁创建的 Class 对象，最后负责运行的 JVM 也退出内存



# 类初始化顺序

![image-20220306213546099](E:\Typora\笔记\JVM.assets\image-20220306213546099.png)



# 垃圾回收机制

## 判断对象存活

- 引用计数器发
  - 每个对象都包含一个引用计数器，用于存放引用次数
  - 每当有一个地方引用此对象，计数+1，引用失效就-1
  - 当计数为0时，表示此对象不再被引用
  - 缺点：需要额外的内存存储计数器，无法解决循环引用
- 可达性分析法
  - 选取一个对象作为gc roots的根节点，有引用就会生成连接，无引用就会断开。
  - 即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历再次标记过程。
  - **标记的前提是对象在进行可达性分析后发现没有与GC Roots相连接的引用链。**
- 最终判断
  - ​	finalize（）



## 垃圾回收算法

![image-20220307142625423](E:\Typora\笔记\JVM.assets\image-20220307142625423.png)

### 基本的三种算法：

- 标记清除算法

  - 其分为两个阶段：标记阶段和清除阶段。

  - 在标记阶段，标记所有由 GC Root 触发的可达对象。此时，所有未被标记的对象就是垃圾对象。
  - 在清除阶段，清除所有未被标记的对象。
  - 标记清除算法最大的问题就是空间碎片问题。如果空间碎片过多，则会导致内存空间的不连续。虽说大对象也可以分配在不连续的空间中，但是效率要低于连续的内存空间。

- 复制算法
  - 将原有的内存空间分为两块，每次只使用一块。
  - 在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中。之后清除正在使用的内存块中的所有对象，之后交换两个内存块的角色，完成垃圾回收。
  - 该算法的缺点是要将内存空间折半，极大地浪费了内存空间。

- ​	标记压缩算法
  - 标记清除算法的优化版，其同样需要经历两个阶段，分别是：标记结算、压缩阶段。
  - 在标记阶段，从 GC Root 引用集合触发去标记所有对象。
  - 在压缩阶段，其则是将所有存活的对象压缩在内存的一边，之后清理边界外的所有空间。



### 分代收集机制

- 根据 JVM 内存的不同内存区域，采用不同的垃圾回收算法。

  - 新生代区域：存活对象少，复制算法，此处的内存并不是对半分，而是Eden、Survivor（from，to） 区域，比例为8:1:1
    - 对象初始创建后在新生代
    - 第一次垃圾回收后，没被回收的会进入Survivor区，每进行一次gc年龄+1，大于15时进入老年代。

  - 老年代：标记压缩算法或标记清除算法，这样不需要移动太多的内存对象



## 垃圾收集类型

- Minor GC：次要垃圾回收，主要进行新生代的垃圾回收
  - 触发条件：新生代的eden区容量已满
- Major GC：主要垃圾回收，主要对老年代的垃圾回收
- FULL GC：完全垃圾回收，对整个Java堆内存和方法区进行垃圾回收
  - 触发条件：
    - 每次晋升到老年代的对象平均大小大于老年代剩余空间
    - Minor GC后存活的存活的对象超过老年代剩余空间
    - 永久代内存不足（jdk1.8前）
    - 手动调用System.gc（）方法

- FULL GC后内存还是不够，抛出OOM异常。

![image-20220307160132885](E:\Typora\笔记\JVM.assets\image-20220307160132885.png)

