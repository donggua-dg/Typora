# 通用语法与分类

sql语句分类

DDL：数据定义语言，定义数据库对象（数据库，表，字段）

DML：数据操作语言，对数据库进行增删改

DQL：数据查询语言，查询数据

DCL：数据控制语言，创建数据库用户，控制数据库访问权限



# 插入数据

1. 给全部字段插入

```sql
insert into 表名 values（值1，值2，...）
```

2. 给指定字段插入

```sql
insert into 表名（字段名1，字段名2，...） values（值1，值2，...）
```

3. 批量插入

```sql
insert into 表名 values（值1，值2，...），（值1，值2，...），（值1，值2，...）
insert into 表名（字段名1，字段名2，...） values（值1，值2，...），（值1，值2，...）
```

4. 将查询结果插入

```
insert into 表名1 
 select 属性 from 表名2 where 条件
```



# 更新数据

```sql
update 表名 set 字段名1=值1，字段名2=值2，... （where 条件）
```

<font color=red>注意：如果没有条件，将会修改整张表的所有数据</font>



# 删除数据

```
delete from 表名 （where 条件）
```

<font color=red>注意：如果没有条件，将会删除整张表的所有数据</font>



# 查询数据

## 语法顺序

```java
1. SELECT 
2. DISTINCT <select_list>
3. FROM <left_table>
4. <join_type> JOIN <right_table>
5. ON <join_condition>
6. WHERE <where_condition>
7. GROUP BY <group_by_list>
8. HAVING <having_condition>
9. ORDER BY <order_by_condition>
10.LIMIT <limit_number>
```



## 基础查询

去重查询：distinct		如：select distinct 字段名 from 表名

1. 查询全部

```
select * from 表名
```

2. 查询指定字段

```
select 字段1，字段2，... from 表名
```



## 条件查询

```
select 字段1，字段2，... from 表名 where 条件
```

![image-20220222221730789](E:\Typora\笔记\typora图片复制存储\image-20220222221730789.png)

### like 字符匹配查询

```
select 字段1，字段2，... from 表名 where 条件 like ‘’
```

1. ' % '  可以代表任意长度的字符串

   如：b%k ,代表以b字母开头，以k结尾的任意长度的字符串，bk，buk，book，break等

2. ' _ ' 只能表示单个字符。

​		如：b_k, 表示b开头，k结尾的三个字符，bok，bak，buk等。

​		如： '__',两个下划线。代表查询只有两个字符的数据。



## 聚合函数

![image-20220222223239408](E:\Typora\笔记\typora图片复制存储\image-20220222223239408.png)

- 应用场景：

  聚合函数可以应用于查询语句的SELECT中，或者HAVING子句中，并结合group by使用。

  注意：不可用于WHERE语句中，因为WHERE是对逐条的行记录进行筛选。

1、count()：求表的行数或者指定表中某个列的列值行数

     select   count(字段)  from  表名;    --得到该列值的行数
    
     select   count(*)   from   表名;     --用于统计整个表的行数。

2、sum()：返回指定数据的和，只能用于数字列，null值被忽略。

     select  sum(salary)   from  emp;   --求所有salary的总和

3、max()：返回一列中的最大值，null值被忽略。

      select   max(column_name)    from   table_name;

 4、min()：返回一列中的最小值，null值被忽略。

      select   max(column_name)    from   table_name;

5、avg()：返回数值列的平均值，，null值被忽略。

     select   avg(salary)   as   avg_sal  from   emp;




## 分组查询

![image-20220222223531389](E:\Typora\笔记\typora图片复制存储\image-20220222223531389.png)

![image-20220222225838831](E:\Typora\笔记\typora图片复制存储\image-20220222225838831.png)



- 单独使用group by，将会只显示一个分组的一条记录

![image-20220222225112210](E:\Typora\笔记\typora图片复制存储\image-20220222225112210.png)

- GROUP BY 与 GROUP_CONCAT()

![image-20220223162332781](E:\Typora\笔记\mysql.assets\image-20220223162332781.png)

- 与集合函数一起使用

![image-20220222225216152](E:\Typora\笔记\typora图片复制存储\image-20220222225216152.png)

- 与having一起使用,过滤分组

![image-20220222225518646](E:\Typora\笔记\typora图片复制存储\image-20220222225518646.png)

- 按多个字段分组

![image-20220222225928242](E:\Typora\笔记\typora图片复制存储\image-20220222225928242.png)

- 与 with rollup一起使用

![image-20220222225959513](E:\Typora\笔记\typora图片复制存储\image-20220222225959513.png)



##  limit限制查询数量

![image-20220223120628373](E:\Typora\笔记\typora图片复制存储\image-20220223120628373.png)

1. 不指定初始位置，从第一条开始，如果指定的数量大于表中的数量，则显示表中所有数据。

```sql
limit 数量
```

![image-20220222230558058](E:\Typora\笔记\typora图片复制存储\image-20220222230558058.png)

2. 指定初始位置

   limit 初始位置，记录数

![image-20220222230832838](E:\Typora\笔记\typora图片复制存储\image-20220222230832838.png)



## 排序查询

![image-20220223120050101](E:\Typora\笔记\typora图片复制存储\image-20220223120050101.png)

- 在不写asc和desc时，默认是升序（asc）
- 对多个字段进行排序时，排序的第一个字段必须有相同的值，才会对第二个字段进行排序。如果第一个字段数据中所有的值都是唯一的，MySQL 将不再对第二个字段进行排序。

![image-20220223162103701](E:\Typora\笔记\mysql.assets\image-20220223162103701.png)

## 查询语句的执行顺序

![](E:\Typora\笔记\typora图片复制存储\image-20220223121242831.png)



# 函数

- 字符串函数
- 数值函数
- 日期函数
- 流程函数



## 字符串函数

![image-20220223123313251](E:\Typora\笔记\typora图片复制存储\image-20220223123313251.png)



## 数值函数

![image-20220223123813878](E:\Typora\笔记\typora图片复制存储\image-20220223123813878.png)



## 日期函数

![image-20220223125756602](E:\Typora\笔记\typora图片复制存储\image-20220223125756602.png)



## 流程函数

![image-20220223130104392](E:\Typora\笔记\typora图片复制存储\image-20220223130104392.png)



# 约束

![image-20220223130259139](E:\Typora\笔记\typora图片复制存储\image-20220223130259139.png)

## 外键约束

- 外键用于与另外一张表的关联，保证数据的完整性

```sql
foreign key（外键名称）references 父表
create table student(
  name varchar(20),
  number int,
  id int,
  foreign key(id) references my_class(id));
```

- 外键使用的条件：
  - 存储引擎是innodb，如果不是Innodb，外键可以创建，但是没有约束效果
  - 外键的字段类型必须与父表的主键要求类型一致
  - 一张表中的外键名称不能重复
  - 增加外键的字段，必须保证数据与主键一致



## 外键约束删除和更新行为

![image-20220223150034146](E:\Typora\笔记\typora图片复制存储\image-20220223150034146.png)



# 多表查询

## 多表关系

![image-20220223150941721](E:\Typora\笔记\typora图片复制存储\image-20220223150941721.png)

![image-20220223151120681](E:\Typora\笔记\typora图片复制存储\image-20220223151120681.png)

![image-20220223151702222](E:\Typora\笔记\typora图片复制存储\image-20220223151702222.png)

## 多表查询概述

![image-20220223152913155](E:\Typora\笔记\typora图片复制存储\image-20220223152913155.png)

![image-20220223152417137](E:\Typora\笔记\typora图片复制存储\image-20220223152417137.png)

子连接：也称“内部查询”或者“嵌套查询”，是指将一个 SELECT 查询（子查询）的结果作为另一个 SQL 语句（主查询）的数据来源或者判断条件。



## 内连接

![image-20220223153558976](E:\Typora\笔记\typora图片复制存储\image-20220223153558976.png)

![image-20220223155203868](E:\Typora\笔记\mysql.assets\image-20220223155203868.png)



## 外连接

- 左外连接

```sql
SELECT <字段名> FROM <表1> LEFT JOIN <表2> <ON子句>
```

- 右外连接

```sql
SELECT <字段名> FROM <表1> RIGHT JOIN <表2> <ON子句>
```



## 自连接

- 针对相同的表进行的连接被称为“自连接”

```sql
select 字段 from 表1 join 表1 on 条件
```



## 联合查询

- 将多个查询的结果合并到一起（纵向合并）：字段数不变，多个查询的记录数合并
- 关键字：union, union all
- 区别
  - UNION去重且排序 
  - UNION ALL不去重不排序
- 将对次查询的结果和合并起来，形成一个新的查询结果集

```sql
select 字段 from 表1，...
union （all）
select 字段 from 表2，...
```

- 使用场景
  - 将同一张表中不同的结果（需要对应多条查询语句来实现），合并到一起展示数据
  - 最常见：在数据量大的情况下，会对表进行分表操作，需要对每张表进行部分数据统计，使用联合查询来将数据存放到一起显示



## 子查询

- sql语句中嵌套select语句，称为嵌套查询，又称子查询

```sql
select 字段 from 表 where 字段属性 = （select 字段属性 from 表2）
```

- 根据查询结果的不同，分为：
  - 标量子查询：（子查询结果为单个值）
  - 列子查询：（子查询结果为一列）
  - 行子查询：（子查询结果为一行）
  - 表子查询：（子查询结果为多行多列）





# 事务

## 基本概念

- 概念：
  - 是一组数据库操作的集合，包含了一组数据库操作命令。
  - 事务把所有的命令作为一个整体一起向系统提交或撤销操作请求，要么都执行，要么都不执行，因此事务是一个不可分割的工作逻辑单元。



## 四大特性

- 原子性：事务是不可分割的最小操作单位，要么全部成功，要么全部失败。
- 一致性：事务完成时，必须使所有的数据都保持一直状态。
- 隔离性：数据库系统提供的隔离机制，保护事务在并发操作时不受外部操作影响。
- 持久性：事务一旦提交或回滚，将会将数据持久化到磁盘中。



## 事务操作

- 默认开启自动提交事务
- 使用select @@autocommit：查看当前事务提交方式，1位自动，0为手动
- 使用set @@autocommit = 0；设置为手动提交事务
- 事务提交：commit
- 事务回滚：rollback



## 并发事务问题

- 脏读

​	一个事务读到另一个事务还没提交的数据，如果另一个事务发生错误并执行回滚，那么读到的数据就死脏数据

- 不可重复读：重在查询

​	一个事务先后读取同一条记录，但两次读取的数据不同

- 幻读：重在新增和修改

​		一个事务先后读取同一条记录，但两次读取的数据不同



## 事务隔离级别

- 读未提交（READ UNCOMMITTED）

- 读提交 （READ COMMITTED）

- 可重复读 （REPEATABLE READ）

- 串行化 （SERIALIZABLE）

| 隔离级别 | 脏读   | 不可重复读 | 幻读   |
| -------- | ------ | ---------- | ------ |
| 读未提交 | 可能   | 可能       | 可能   |
| 读提交   | 不可能 | 可能       | 可能   |
| 重复读   | 不可能 | 不可能     | 可能   |
| 串行化   | 不可能 | 不可能     | 不可能 |

- 默认的隔离级别：可重复读（基本不会修改）
- 事务隔离级别越高，数据越安全，但性能越低



# 存储引擎

## InnoDB

- 兼顾高性能和高可靠性的通用存储引擎，在mysql5.5版本后，InnoDB为默认的存储引擎
- DML操作遵循ACID模型，支持事务，支持外键约束

- 适用场景：用于事务处理，具有ACID事物支持，应用于执行大量的insert和update操作的表



## MyISAM

- 不支持事务，不支持外键约束，不支持行级锁，操作时需要锁定整张表，不过会保存表的行数，所以当执行select count(*) from tablename时执行特别快。
- 适用场景：用于管理非事务表，提供高速检索及全文检索能力，适用于有大量的select操作的表，如 日志表



## MEMORY

- 基于内存存储，断电即失，只能用作临时表或缓存使用
- 使用hash索引，可以一次定位，所以精确查询时访问速度特别快



# 索引

- 索引是一种特殊的数据库结构，可以用来快速查询数据表中有某一特定值的记录。

- mysql中，通常使用的两种数据库访问方式：
  - 顺序访问：全表访问，从头到尾遍历
  - 索引访问：遍历索引来直接访问

- 优点
  - 大大加快数据的查询速度
- 缺点
  - 占用内存空间
  - 降低了更新表的效率（insert，update，delete）



## 索引结构

| 索引结构              | 描述                                                         |
| --------------------- | ------------------------------------------------------------ |
| B+Tree索引            | 最常见，大部分引擎都支持                                     |
| Hash索引              | 只有精确匹配索引列的查询才有效，不支持范围查询               |
| R-Tree（空间索引）    | MyISAM引擎使用的一个特殊引擎，主要用于地理空间数据类型，通常使用较少 |
| Full-text（全文索引） | 是一种通过建立倒排索引快速匹配文档的方式                     |



## 索引分类

| 分类     | 含义                                   | 特点       | 关键字   |
| -------- | -------------------------------------- | ---------- | -------- |
| 主键索引 | 针对主键创建的索引                     | 默认创建   | primary  |
| 唯一索引 | 避免同一表中某数据列中的值重复         | 可以有多个 | unique   |
| 常规索引 | 快速定位特定数据                       | 可以有多个 |          |
| 全文索引 | 查找文本中的关键词，而不是比较索引的值 | 可以有多个 | fulltext |

在InnoDB引擎中，根据索引的存储形式，分为

| 分类     | 含义                                                     | 特点           |
| -------- | -------------------------------------------------------- | -------------- |
| 聚集索引 | 将数据存储与索引放在一块，索引结构的叶节点保存了行数据   | 必须且只有一个 |
| 二级索引 | 将数据与索引分开存储，索引结构的叶节点关联的是对应的主键 | 可以有多个     |

- 如果存在主键，把主键作为聚集索引
- 没有主键，将使用第一个唯一索引作为聚集索引
- 没有主键，也没有唯一索引，则InnoDB自动生成一个rowid作为隐藏的聚集索引



## 创建索引

```sql
create index 索引名 on 表名 （字段）
```



## 查看索引

```sql
SHOW INDEX FROM <表名> [ FROM <数据库名>]
```



## 最左前缀法则

- 当使用了联合索引（多列），最左边的索引必须有使用，否则索引会失效
- 有使用最左边，当跳过了部分列，跳过的部分将失效。



## 索引失效情况

- 在索引列进行运算
- 字符串类型不加单引号
- 模糊查询：尾部模糊查询不会失效，头部模糊查询将会失效

- or条件查询：or两边的列都使用了索引，索引才会生效，否则索引失效

- 数据库自评估：数据库认为全表比索引效率高，索引将会失效



## 覆盖索引&回表查询

- 一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。当一条查询语句符合覆盖索引条件时，MySQL 只需要通过索引就可以返回查询所需要的数据，这样避免了查到索引后再返回表操作，减少 I/O 提高效率。
- 尽量使用覆盖索引，减少select *

- 回表查询
  - 数据库根据索引（非主键）找到了指定的记录所在行后，还需要根据索引上保存的主键 ID 再次到数据块里获取数据。
  - 如何避免：将需要的字段放在索引中去，查询的时候就能避免回表。



## 索引设计原则

- 数据量大，查询比较频繁的表
- 常用于查询条件（where），排序（order by），分组（group by）操作的字段建立索引
- 不同值不多的（如男女性别），不建议建立索引
- 字符串类型的，长度较长的使用前缀索引
- 尽量使用联合索引，减少单列索引，避免回表
- 控制索引数量，不是越多越好



## 前缀索引

- 当索引类型的列为字符串时（varchar，text），可能需要索引很长的字符串，会导致索引变大，浪费磁盘空间。
- 只将一部分字符串的前缀作为索引，减少索引占用空间，提高效率。

```
create index 索引名 on table 字段属性（n）
```





# 索引优化

## explain

```sql
explain select 字段 from 表
```

- 字段说明：

  - id

  select查询的序列号，表示执行查询语句时操作表的顺序（id相同，顺序上到下；id不同，值越大，越先执行）

  - select_type

    选择的类型，

    ​	simple（简单表，即不使用表连接或者子查询）

    ​	primary（主查询，即外层查询）

    ​	union（union中的第二个或者后面的查询语句）

    ​	subquery（select/where之后包含了子查询）

  - type

    表示连接类型，性能由好到差：null，system，const，eq_ref，ref，range，index，all

    system：系统表，少量数据，往往不需要进行磁盘 IO
    const：常量连接
    eq_ref：主键索引 (primary key) 或者非空唯一索引 (unique not null) 等值扫描
    ref：非主键非唯一索引等值扫描
    range：范围扫描
    index：索引树扫描
    ALL：全表扫描 (full table scan)

  - possible_key

    - 显示查询可能使用哪些索引来查找
    - key 为 NULL，说明表中数据不多，mysql认为索引对此查询帮助不大，选择了全表查询

  - key
    - 显示mysql实际采用哪个索引来优化对该表的访问
    - 没有使用索引，为null

  - key_len
    - 显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列
    
  - extra
  
    展示的是额外信息
  
    - **`distinct`**: 一旦mysql找到了与行相联合匹配的行，就不再搜索了
  
    - **`Using index`**：这发生在对表的请求列都是同一索引的部分的时候，返回的列数据只使用了索引中的信息，而没有再去访问表中的行记录。是性能高的表现。
  
    - **`Using where`**：mysql服务器将在存储引擎检索行后再进行过滤。就是先读取整行数据，再按 where 条件进行检查，符合就留下，不符合就丢弃。
  
    - **`Using temporary`**：mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行优化的，首先是想到用索引来优化。
  
    - **`Using filesort`**：mysql 会对结果使用一个外部索引排序，而不是按索引次序从表里读取行。此时mysql会根据联接类型浏览所有符合条件的记录，并保存排序关键字和行指针，然后排序关键字并按顺序检索行信息。这种情况下一般也是要考虑使用索引来优化的。
  
      



# sql优化

## 插入优化

- 多条插入语句改为批量插入

```
insert into 表 values（），（），（）...
```

- 如果为多条插入语句，手动提交事务
- 主键顺序插入



## 主键优化

- 尽量降低主键的长度
- 插入时。尽量顺序插入，选择auto_increment自增主键



## order by优化

- .using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫filesort排序。
- .using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为using index，不需要额外排序，操作效率高。

- 排序字段建立合适的索引，多字段排序，遵从最左前缀法则
- 尽量使用覆盖索引
-  

