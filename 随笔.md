**jvm组成**

类加载器

运行时数据数据区

执行引擎

本地接口



java-class-类加载器-运行时数据区-执行引擎，本地接口



浅拷贝：指针指向已存在的地址，不开辟新内存

深拷贝：复制数据到一个新内存





**jvm中堆栈区别**

堆：物理地址不连续，内存分配在运行期，大小不固定，

​		存对象的实例和数组

栈：连续，内存分配在编译器确定，大小固定，先进后出，性能快，

​		存局部变量，操作数栈，返回结果



java堆内存划分





**队列和栈**

都是存储数据

操作方式不同：栈操作都在栈顶，队列进队在尾，出队在头

操作方法不同：队列，先进先出，栈先进后出





**对象创建方式**

- new
- class.newInstance 	public公共无参构造
- clone  	继承Cloneable接口
- constructor 
- 反序列化		Serializable接口



**对象如何创建的**

查询常量池

- 无，类加载器
- 有，在堆分配内存



**内存分配方式**

根据堆内存是否完整决定

- 指针碰撞	内存完整，一边空闲，一边不空闲，直接在空闲区分配指定内存空间
- 空闲列表    内存不完整	，记录可用空闲内存，选取一块足够大小空间的内存分配



**内存泄漏**

oom：内存

长期不使用的资源占据内存空间得不到释放



**java存在内存泄漏**

长生命周期的对象持有短生命周期对象的引用，

尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收



**垃圾回收机制**

在JVM中，有一个垃圾回收线程，它是低优先级的，正常情况下不会执行，

只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。



**GC是什么？**

GC 是垃圾收集的意思

**为什么要GC**

回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动



**垃圾回收的优点和原理**

使java程序员在编写程序时不再考虑内存管理的问题



**Java 中都有哪些引用类型？**

不同的对象引用类型， GC会采用不同的方法进行回收

- 强引用：不会被回收。
- 软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。
- 弱引用：有用但不是必须的对象，无论内存是否足够，jvm开始进行垃圾回收都会被回收
- 虚引用（幽灵引用/幻影引用）：随时可能被回收 



**如何判断对象是否可以被回收**

- 存活，不回收，死亡，被回收

- 判断方法

  - 引用计数器法

    有引用，计数器+1，引用释放-1，等于0时可以被回收，无法解决循环引用问题

  - 可达性分析算法

    探索引用链，无引用链可以被回收



**什么时候可以回收**

当一个对象到GC Roots（可达性分析算法）不可达时，在下一个垃圾回收周期中尝试回收该对象





**垃圾回收算法**

标记-清除：对死亡的进行标记，清除，缺点，效率低，且清理后内存杂乱

复制：内存对半分

标记-整理

分代：存活周期，新生代，老年代，新生代采用复制，老年代采用标记-整理



**什么是类加载器，种类？**

- 启动类加载器               加载java核心类库
- 扩展类                          加载扩展库

- 系统类                         根据类路径classpath加载java类
- 用户自定义               

双亲委派模型：类加载器收到类加载请求，先给父类，父类不能解决，再自己处理



**类java加载机制**

加载，验证，准备，解析，初始化



**类装载方式**

- 隐式       new对象，隐式调佣来类加载器加载到jvm
- 显示       通过class，forname（）等方法，显示加载需要的类

java类，动态加载，按需加载，节省内存









